'''

CCD Data Layer - Control Architecture

Overview

This implementation creates a robust frame-based architecture for the TCD1304DG CCD sensor.  Written for the STM32F401CCU6 MCU, but fairly easily extensible to other STM32 controllers, the firmware and architecture is designed to deal with the hard stuff robustly and flexibly (timers, buffering, essential sensor control, user interaction. etc), but in as small a codebase as possible.  As such, the code includes a robust, flexible, and accurate data/comms stack, and 

 Parsing the output of the CCD presents several challenges, and the method of structuring data directly effects the practical use of the sensor. Given my objectives and overall architecture, I define a 'frame' is the mimimum viable, atomic unit of sensor data transfer/output, equal to one complete read of all of the sensors pixels, icluding the dummy pixels.  This allows for clear marking of the frame boundries, the use of a checksum field to verify data integrity, and a simple means by which Python will always receive complete, validated sensor readouts (at no point can the code send fragments/partial reads).  The overall firmware and python control software is built in three, discretely coded conceptual 'layers': a data layer (plumbing and ADC buffers, etc.) a control layer, USB comms, I/O between python on one side and the data layer on the other, and a command layer (what python uses to control MCU/sensor).  Per below diagram, I've intentionally kept the first two layers binary and the latter ASCII (after parsing/controlling binary input).  This just seemed clean to me, as the overall design principle has been to make firmware robust and powerful, but with no unnecessary features/controls, except those invoked by python (I intentionally wrote the code without a firmware CLI, as I don't need it, and thus its just bloat for my purposes).  The idea being, once written, I can set it and forget it, and focus on python or whatever other local (mac/pc) tools used for sampling, calibrating, analysis, etc).  

Aside from pin assignment and MCU specific timing, the same data and I/O stack should be resusable and extensible.


A note on dummy pixels: These (D0-31, and D32-45 on the DG version of the sensor with 3694 total elements) are not completely dumb.  Rather, they aquire actual electrical charge during sampling, but they are blind to light.  Note that the active elements/pixels, those that can sense light (S1-S3648), exist in the middle of the dummy pixel rows on the sensor surface.  What are the dummy pixels for?  Who knows, but they can be used very constructively.  For example, the reading of dummy pixels can be used to determine what is dark signal and what is electrical noise, and so these too are read.  Thus the entire frame unit in this code includes all elements, D and S, which must be parsed and processed (or discarded) by python.  I use these for both calibration, signal processing and testing, and so they are included in the atomic frame unit generated by the code. 


Architecture Philosophy

The firmware is organized in three conceptual layers:

┌─────────────────────────────────────┐
│   USER/COMMAND LAYER                │  ← Python interfaces here
│   (ASCII, human-readable)           │
├─────────────────────────────────────┤
│   CONTROL/TRANSPORT LAYER           │  ← USB ring buffers
│   (Binary data movement)            │
├─────────────────────────────────────┤
│   DATA LAYER                        │  ← Frame marking happens HERE
│   (CCD → RAM with frame markers)   │
└─────────────────────────────────────┘
```

**Key principle**: Frame marking happens at the **DATA LAYER** (lowest boundary), ensuring the contract cannot be broken by higher layers.

## TCD1304DG Sensor Specifications

- **Total elements per readout**: 3694
- **Effective signal pixels**: 3648 (S0-S3647)
- **Dummy pixels**: 46 (light-shielded + test outputs)

### Pixel Layout (left to right on sensor):

D0-D15:   16 dummy outputs (light-shielded)
D16-D28:  13 light-shielded outputs
D29-D31:   3 transition elements
S0-S3647: 3648 SIGNAL PIXELS (this is your spectral data!)
D32-D45:  14 dummy outputs

All pixels are captured and transmitted. Python will handle filtering/labeling.

Frame Structure

Each frame is **7402 bytes** and contains:

┌────────────────────────────────────────┐
│ START MARKER: "FRME" (4 bytes)        │  0x46524D45
├────────────────────────────────────────┤
│ FRAME COUNTER: uint16_t (2 bytes)     │  Wraps at 65535
├────────────────────────────────────────┤
│ PIXEL COUNT: uint16_t (2 bytes)       │  Always 3694
├────────────────────────────────────────┤
│ PIXEL DATA: 3694 × 2 bytes            │  7388 bytes of ADC values
│   (uint16_t array)                     │  12-bit ADC right-aligned
├────────────────────────────────────────┤
│ END MARKER: "ENDF" (4 bytes)          │  0x454E4446
├────────────────────────────────────────┤
│ CHECKSUM: CRC16 (2 bytes)             │  CRC-16-CCITT
└────────────────────────────────────────┘
Total: 7402 bytes


Python Integration Strategy - the below are basic paramaters and design elements required for python integration.  I have also included some basic test scripts to ensure everything is working.   

# Frame Detection
```python
# Search for start marker
START_MARKER = b'FRME'
END_MARKER = b'ENDF'

# Find frame boundaries
frame_start = data.find(START_MARKER)
if frame_start >= 0:
    frame_data = data[frame_start:frame_start + 7402]

### Frame Parsing
```python
import struct

# Unpack frame header
start_marker, frame_counter, pixel_count = struct.unpack('<IHH', frame_data[0:8])

# Extract pixel data (3694 uint16_t values)
pixels = struct.unpack('<3694H', frame_data[8:7396])

# Verify footer
end_marker, checksum = struct.unpack('<IH', frame_data[7396:7402])

### Pixel Labeling (in Python)
```python
# Pixel map for TCD1304DG
PIXEL_MAP = {
    'dummy_start': (0, 16),       # D0-D15
    'light_shield': (16, 29),     # D16-D28
    'transition_1': (29, 32),     # D29-D31
    'signal': (32, 3680),         # S0-S3647 (THE SPECTRAL DATA!)
    'transition_2': (3680, 3683), # D32-D34
    'dummy_end': (3683, 3694),    # D35-D45
}

# Extract signal pixels only
```python
signal_pixels = pixels[32:3680]

# Label with wavelength (after calibration)
```python
wavelengths = np.linspace(start_nm, end_nm, 3648)
spectrum = pd.DataFrame({
    'wavelength_nm': wavelengths,
    'intensity': signal_pixels
})
```

### CRC16 Validation (in Python)
```python
def crc16_ccitt(data):
    crc = 0xFFFF
    for byte in data:
        crc ^= (byte << 8)
        for _ in range(8):
            if crc & 0x8000:
                crc = (crc << 1) ^ 0x1021
            else:
                crc <<= 1
        crc &= 0xFFFF
    return crc

# Validate frame
calc_crc = crc16_ccitt(frame_data[0:7400])
if calc_crc == checksum:
    print("Frame valid!")
```

Other design considerations

I used the increadibly helpful tutorial of curiousscientist to get my head around the essential timers.  I stil don't think I fully understand them, but outside of declating the specific buffer sizes in the USB file, I kept things exactly as he set them.

His blog post on this topic: https://curiousscientist.tech/blog/tcd1304-linear-ccd-driving-the-ccd

That said, a few things required some thought to make sense of.  These include:

Buffer Configurations

ADC Buffer (main.c)
```c
#define CCDBuffer 6000
volatile uint16_t CCDPixelBuffer[CCDBuffer];
```
Why 6000?

- Current sensor needs: 3694 pixels
- Frame needs: 3694 pixels
- Headroom for variable integration times
- RAM is plentiful (64KB on STM32F401)
- Proven working in original implementation

Thus I kept at 6000 - no reason to change

USB Buffer Sizing

The USB transport buffers must accommodate frame size:
- Minimum: 7402 bytes per frame
- Recommended: 8192 bytes (power of 2, allows buffering)

Check `usb_transport.h` for:
```c
#define USB_TX_BUFFER_SIZE  8192  // Or larger
```

Overall Data Flow

1. TIM2 triggers integration period (ICG pulse)
   └─> 630ms period (7500μs integration for 2 duty cycles)

2. TIM4 triggers ADC conversions
   └─> One conversion per pixel shift clock

3. DMA transfers ADC values to CCDPixelBuffer[]
   └─> 3694 samples collected

4. HAL_ADC_ConvCpltCallback() fires
   └─> Calls ccd_data_layer_process_readout()
       ├─> Adds frame markers
       ├─> Increments frame counter
       ├─> Calculates CRC16 checksum
       └─> Returns complete CCD_Frame_t structure

5. Complete frame sent via CDC_Transmit_FS()
   └─> 7402 bytes transmitted over USB

6. Python receives complete, validated frame
   └─> Never partial data!

Implementation Files

New Files added to the curiousscientist basic firmware:

1. **ccd_data_layer.h** - Frame structure definitions and API
2. **ccd_data_layer.c** - Frame processing implementation

Modified Files:
1. **main.c** - Add frame processing in ADC callback
   - Add: `#include "ccd_data_layer.h"`
   - Add: `ccd_data_layer_init()` in setup
   - Modify: `HAL_ADC_ConvCpltCallback()` to use frame processing

Key Benefits

**Atomic guarantee**: Python never receives partial frames
**Error detection**: CRC16 catches transmission errors
**Frame synchronization**: Start/end markers prevent drift
**Frame counting**: Detect dropped frames
**Validation**: Multiple integrity checks
**Future-proof**: Easy to add metadata to frame header
**Clean separation**: Data layer stays binary, Python handles ASCII

Next Steps

Firmware:
1. Add `ccd_data_layer.c` and `ccd_data_layer.h` to your STM32 project
2. Update `main.c` with the modified ADC callback
3. Compile and test

Python:
1. Create frame parser class
2. Implement CRC validation
3. Create pixel mapping/labeling
4. Add spectral calibration
5. Build data export (CSV, etc.)

Testing Strategy

### Firmware Test:
```c
// In main loop, verify frame structure
if (ccd_data_layer_validate_frame(&current_frame) == CCD_FRAME_OK) {
    // Frame is valid
}
```

### Python Test:
```python
# Basic connectivity test
while True:
    data = serial_port.read(7402)
    if data.startswith(b'FRME') and data[7396:7400] == b'ENDF':
        print(f"Valid frame received!")
        frame_count = struct.unpack('<H', data[4:6])[0]
        print(f"Frame #{frame_count}")



Python reassembly and assigment of pixel label in 2 column .csv format (of binary frame:

# Find frame
data = ser.read(large_buffer)
start_idx = data.find(b'FRME')
end_idx = data.find(b'ENDF')

# Extract frame
frame_bytes = data[start_idx:end_idx+4]

# Unpack the structure
import struct
# Skip past "FRME" (4 bytes), frame_counter (2), pixel_count (2) = 8 bytes total
pixel_data_start = 8
pixel_data_bytes = frame_bytes[pixel_data_start:pixel_data_start + (3694*2)]

# Convert binary to list of integers
pixel_values = struct.unpack('<3694H', pixel_data_bytes)
# Now pixel_values = [value_D0, value_D1, ..., value_S1, value_S2, ..., value_S3648, ..., value_D45]

Notes

- All multi-byte values are **little-endian** (STM32 native format)
- Frame counter wraps at 65535 (this is intentional)
- Dummy pixels contain useful noise floor data - don't discard until Python
- CRC polynomial: 0x1021 (CRC-16-CCITT standard)

---

**Questions? Issues?**

- Frame too large? Check USB_TX_BUFFER_SIZE
- Missing frames? Check frame counter gaps
- Bad checksums? Verify endianness in Python
- Wrong pixel count? Should always be 3694



Let me know how this works for you, please!